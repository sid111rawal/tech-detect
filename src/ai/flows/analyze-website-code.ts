// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview Flow for analyzing website code to detect technologies using signature-based methods.
 *
 * - analyzeWebsiteCode - A function that analyzes website code.
 * - AnalyzeWebsiteCodeInput - The input type for the analyzeWebsiteCode function.
 * - AnalyzeWebsiteCodeOutput - The return type for the analyzeWebsiteCode function.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import {retrievePageContent, type PageContentResult} from '@/services/page-retriever';
import { detectTechnologies, signatures as signaturesDb } from '@/lib/signatures'; // Updated import

// Define the schema for detected technologies
const DetectedTechnologySchema = z.object({
  id: z.string().optional().describe('An identifier for the detection rule or signature if applicable.'), // Made optional
  technology: z.string().describe('The name of the detected technology, library, or framework.'),
  version: z.string().optional().describe('The detected version of the technology, if identifiable.'),
  confidence: z.number().min(0).max(1).describe('The confidence score (0.0 to 1.0) of this detection.'),
  isHarmful: z.boolean().optional().describe('Whether this technology, in its detected form or version, poses a direct security risk or is often associated with vulnerabilities. Can be determined by AI.'),
  detectionMethod: z.string().optional().describe('Brief description of how this technology was identified (e.g., "Signature: React (scriptSrc)", "Signature: HTML comment analysis", "Signature: Code pattern in minified script").'), // Made optional
  category: z.string().optional().describe('A category for the technology (e.g., "JavaScript Framework", "Analytics", "CMS", "Web Server", "CDN", "UI Library", "Payment Processor", "Security"). Standardize these as much as possible.'),
  matchedValue: z.string().optional().describe('The actual string value from the source code or headers that matched a pattern or was used for inference.'),
  website: z.string().optional().describe('Official website of the technology, if known.'),
  icon: z.string().optional().describe('Filename of the technology icon (e.g., "React.svg").'),
});
export type DetectedTechnology = z.infer<typeof DetectedTechnologySchema>;


const AnalyzeWebsiteCodeInputSchema = z.object({
  url: z.string().url().describe('The URL of the website to analyze.'),
});
export type AnalyzeWebsiteCodeInput = z.infer<typeof AnalyzeWebsiteCodeInputSchema>;

const AnalyzeWebsiteCodeOutputSchema = z.object({
  detectedTechnologies: z.array(DetectedTechnologySchema).describe('A list of detected technologies with their details.'),
  securityConcerns: z.array(z.string()).describe('A list of potential security concerns identified. (Currently not populated by this non-AI flow)'),
  analysisSummary: z.string().describe('A brief summary of the analysis.'),
  error: z.string().optional().describe('An error message if the analysis failed at a high level.'),
});
export type AnalyzeWebsiteCodeOutput = z.infer<typeof AnalyzeWebsiteCodeOutputSchema>;

export async function analyzeWebsiteCode(
  input: AnalyzeWebsiteCodeInput
): Promise<AnalyzeWebsiteCodeOutput> {
  console.log('[FlowWrapper/analyzeWebsiteCode] Calling flow with input:', input);
  try {
    const result = await analyzeWebsiteCodeFlow(input);
    console.log('[FlowWrapper/analyzeWebsiteCode] Flow returned result:', result);
    return result;
  } catch (error) {
    console.error('[FlowWrapper/analyzeWebsiteCode] Error calling flow:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return {
      detectedTechnologies: [],
      securityConcerns: [],
      analysisSummary: `Error during analysis: ${errorMessage}. The website content might be inaccessible or an unexpected issue occurred.`,
      error: `Error during analysis: ${errorMessage}.`
    };
  }
}

const retrievePageContentTool = ai.defineTool(
  {
    name: 'retrievePageContent',
    description: 'Retrieves the HTML content, response headers, and potentially cookies of a given URL using puppeteer.',
    inputSchema: z.object({
      url: z.string().url().describe('The URL of the website to retrieve content from.'),
    }),
    outputSchema: z.object({
        html: z.string().nullable().describe('The HTML content of the page, or null if an error occurred.'),
        headers: z.record(z.string(), z.union([z.string(), z.array(z.string())])).optional().describe('Response headers from the server.'),
        cookies: z.string().optional().describe('Cookies string from Set-Cookie headers or document.cookie (if applicable).'),
        error: z.string().optional().describe('An error message if fetching failed.'),
        status: z.number().optional().describe('HTTP status code of the response.'),
        finalUrl: z.string().url().optional().describe('The final URL after any redirects.')
    }),
  },
  async ({url}): Promise<PageContentResult> => {
    console.log(`[Tool/retrievePageContent] Attempting to fetch with puppeteer: ${url}`);
    try {
      const result = await retrievePageContent(url); 
      if (result.error) {
        console.warn(`[Tool/retrievePageContent] Puppeteer error fetching ${url}: ${result.error}`);
      } else {
        console.log(`[Tool/retrievePageContent] Puppeteer successfully fetched ${url}. HTML length: ${result.html?.length}, Headers: ${Object.keys(result.headers || {}).length}`);
      }
      return result;
    } catch (e: any) {
      console.error(`[Tool/retrievePageContent] Puppeteer exception during fetch for ${url}:`, e);
      return {html: null, error: e.message || 'Unknown error during page retrieval with puppeteer.'};
    }
  }
);

const analyzeWebsiteCodeFlow = ai.defineFlow(
  {
    name: 'analyzeWebsiteCodeFlow',
    inputSchema: AnalyzeWebsiteCodeInputSchema,
    outputSchema: AnalyzeWebsiteCodeOutputSchema,
  },
  async (input): Promise<AnalyzeWebsiteCodeOutput> => {
    const flowLogPrefix = `[SignatureFlow/analyzeWebsiteCodeFlow URL: ${input.url}]`;
    console.log(`${flowLogPrefix} Flow starting.`);

    const pageContentResult = await retrievePageContentTool({ url: input.url });

    if (!pageContentResult.html || pageContentResult.error) {
      console.warn(`${flowLogPrefix} Failed to retrieve HTML: ${pageContentResult.error || 'No HTML content'}`);
      return {
        detectedTechnologies: [],
        securityConcerns: [],
        analysisSummary: `Failed to retrieve website content for ${input.url}. Error: ${pageContentResult.error || 'No HTML content returned.'} Analysis cannot proceed. (Status: ${pageContentResult.status})`,
        error: `Failed to retrieve website content for ${input.url}. Error: ${pageContentResult.error || 'No HTML content returned.'} (Status: ${pageContentResult.status})`,
      };
    }
    console.log(`${flowLogPrefix} HTML content retrieved. Length: ${pageContentResult.html.length}. Headers received: ${!!pageContentResult.headers}, Cookies: ${!!pageContentResult.cookies}`);

    let signatureDetections: DetectedTechnology[] = [];
    try {
      // Use detectTechnologies from src/lib/signatures.ts
      const detectedByCategory = detectTechnologies(pageContentResult.html, pageContentResult.headers || {});
      
      for (const category in detectedByCategory) {
        const technologiesInCategory = detectedByCategory[category];
        for (const tech of technologiesInCategory) {
          // Find the original signature definition to get website/icon if available
          let originalSignature;
          for (const sigCategoryKey in signaturesDb) {
              const sigArray = signaturesDb[sigCategoryKey as keyof typeof signaturesDb] as Array<any>;
              originalSignature = sigArray.find(s => s.name === tech.name);
              if (originalSignature) break;
          }

          signatureDetections.push({
            id: originalSignature?.id || `${category}-${tech.name}`, // Create an ID if none
            technology: tech.name,
            version: tech.version || undefined,
            confidence: tech.confidence, // Already 0-1 from detectTechnologies
            // isHarmful: undefined, // isHarmful was AI-determined, set to undefined now.
            detectionMethod: "Signature-based detection", // Generic method
            category: originalSignature?.category || category,
            // matchedValue: undefined, // Not provided by detectTechnologies in this form
            website: originalSignature?.website,
            icon: originalSignature?.icon,
          });
        }
      }

      console.log(`${flowLogPrefix} Signature-based detection found ${signatureDetections.length} technologies.`);
      signatureDetections.forEach(tech => console.log(`  ${flowLogPrefix} - Signature: ${tech.technology} (v${tech.version || 'N/A'}, conf: ${tech.confidence}) via ${tech.detectionMethod}`));
    } catch (e: any) {
      console.error(`${flowLogPrefix} Error during signature-based detection:`, e.message, e.stack);
      return {
        detectedTechnologies: [],
        securityConcerns: [],
        analysisSummary: `Error during signature-based detection: ${e.message || 'Unknown error'}.`,
        error: `Error during signature-based detection: ${e.message || 'Unknown error'}.`,
      };
    }
    
    const analysisSummary = signatureDetections.length > 0 
        ? `Signature-based analysis complete. Detected ${signatureDetections.length} technology/technologies.`
        : `Signature-based analysis complete. No technologies detected with current signatures for ${input.url}.`;

    const output: AnalyzeWebsiteCodeOutput = {
        detectedTechnologies: signatureDetections,
        securityConcerns: [], // No AI to generate security concerns
        analysisSummary: analysisSummary,
    };

    console.log(`${flowLogPrefix} Signature-based analysis successful. Detected ${output.detectedTechnologies.length} technologies.`);
    return output;
  }
);