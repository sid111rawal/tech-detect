
// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview AI flow for analyzing website code to detect technologies and security concerns.
 *
 * - analyzeWebsiteCode - A function that analyzes website code.
 * - AnalyzeWebsiteCodeInput - The input type for the analyzeWebsiteCode function.
 * - AnalyzeWebsiteCodeOutput - The return type for the analyzeWebsiteCode function.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import {retrievePageContent, type PageContentResult} from '@/services/page-retriever'; // Updated import
import { detectWithSignatures, type DetectedTechnologyInfo as SignatureDetectedTechInfo, type DetectionInput } from '@/lib/signatures'; // Updated import

// Define the schema for detected technologies
const DetectedTechnologySchema = z.object({
  id: z.string().describe('An identifier for the detection rule or signature if applicable.'), // From signature or AI
  technology: z.string().describe('The name of the detected technology, library, or framework.'),
  version: z.string().optional().describe('The detected version of the technology, if identifiable.'),
  confidence: z.number().min(0).max(1).describe('The confidence score (0.0 to 1.0) of this detection.'),
  isHarmful: z.boolean().optional().describe('Whether this technology, in its detected form or version, poses a direct security risk or is often associated with vulnerabilities. Can be determined by AI.'),
  detectionMethod: z.string().describe('Brief description of how this technology was identified (e.g., "Signature: React (scriptSrc)", "AI: Inferred from global variable pattern", "AI: HTML comment analysis", "AI: Code pattern in minified script").'),
  category: z.string().optional().describe('A category for the technology (e.g., "JavaScript Framework", "Analytics", "CMS", "Web Server", "CDN", "UI Library", "Payment Processor", "Security"). Standardize these as much as possible.'),
  matchedValue: z.string().optional().describe('The actual string value from the source code or headers that matched a pattern or was used for inference.'),
  website: z.string().optional().describe('Official website of the technology, if known.'),
  icon: z.string().optional().describe('Filename of the technology icon (e.g., "React.svg").'),
});
export type DetectedTechnology = z.infer<typeof DetectedTechnologySchema>;


const AnalyzeWebsiteCodeInputSchema = z.object({
  url: z.string().url().describe('The URL of the website to analyze.'),
});
export type AnalyzeWebsiteCodeInput = z.infer<typeof AnalyzeWebsiteCodeInputSchema>;

const AnalyzeWebsiteCodeOutputSchema = z.object({
  detectedTechnologies: z.array(DetectedTechnologySchema).describe('A list of detected technologies with their details.'),
  securityConcerns: z.array(z.string()).describe('A list of potential security concerns identified from the code.'),
  analysisSummary: z.string().describe('A brief summary of the analysis, including any issues encountered (e.g., failed to fetch page).'),
});
export type AnalyzeWebsiteCodeOutput = z.infer<typeof AnalyzeWebsiteCodeOutputSchema>;

export async function analyzeWebsiteCode(
  input: AnalyzeWebsiteCodeInput
): Promise<AnalyzeWebsiteCodeOutput> {
  console.log('[AIFlowWrapper/analyzeWebsiteCode] Calling flow with input:', input);
  try {
    const result = await analyzeWebsiteCodeFlow(input);
    console.log('[AIFlowWrapper/analyzeWebsiteCode] Flow returned result:', result);
    return result;
  } catch (error) {
    console.error('[AIFlowWrapper/analyzeWebsiteCode] Error calling flow:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`[AIFlowWrapper/analyzeWebsiteCode] Full error: ${errorMessage}`, error);
    // Log the full error for better debugging on the server
    // console.error('[AIFlowWrapper/analyzeWebsiteCode] Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
    return {
      detectedTechnologies: [],
      securityConcerns: [],
      analysisSummary: `Error during analysis: ${errorMessage}. The website content might be inaccessible, the analysis process failed, or an unexpected issue occurred. Please check server logs for details.`,
    };
  }
}

const retrievePageContentTool = ai.defineTool(
  {
    name: 'retrievePageContent',
    description: 'Retrieves the HTML content, response headers, and potentially cookies of a given URL. This should be the first step in the analysis.',
    inputSchema: z.object({
      url: z.string().url().describe('The URL of the website to retrieve content from.'),
    }),
    outputSchema: z.object({
        html: z.string().nullable().describe('The HTML content of the page, or null if an error occurred.'),
        headers: z.record(z.string(), z.union([z.string(), z.array(z.string())])).optional().describe('Response headers from the server.'),
        cookies: z.string().optional().describe('Cookies string from Set-Cookie headers or document.cookie (if applicable).'),
        error: z.string().optional().describe('An error message if fetching failed.'),
        status: z.number().optional().describe('HTTP status code of the response.'),
        finalUrl: z.string().url().optional().describe('The final URL after any redirects.')
    }),
  },
  async ({url}): Promise<PageContentResult> => {
    console.log(`[Tool/retrievePageContent] Attempting to fetch: ${url}`);
    try {
      const result = await retrievePageContent(url); 
      if (result.error) {
        console.warn(`[Tool/retrievePageContent] Error fetching ${url}: ${result.error}`);
      } else {
        console.log(`[Tool/retrievePageContent] Successfully fetched ${url}. HTML length: ${result.html?.length}, Headers: ${Object.keys(result.headers || {}).length}`);
      }
      return result;
    } catch (e: any) {
      console.error(`[Tool/retrievePageContent] Exception during fetch for ${url}:`, e);
      return {html: null, error: e.message || 'Unknown error during page retrieval.'};
    }
  }
);

const AnalyzeWebsiteCodePromptInputSchema = z.object({
  url: z.string().url(),
  htmlContent: z.string().describe('The HTML content of the page.'),
  headers: z.record(z.string(), z.union([z.string(), z.array(z.string())])).optional().describe('Response headers from the server.'),
  cookies: z.string().optional().describe('Cookies string.'),
  signatureBasedDetections: z.array(DetectedTechnologySchema).describe('Technologies already detected by initial signature scanning (potentially using headers, cookies, URL, and HTML). Use this to guide and augment your analysis, not just repeat it. Focus on finding *additional* technologies or confirming/refining these with more evidence, especially from obfuscated code or behavioral patterns not covered by simple signatures.')
});


const analyzeWebsiteCodePrompt = ai.definePrompt({
  name: 'analyzeWebsiteCodePrompt',
  input: {schema: AnalyzeWebsiteCodePromptInputSchema },
  output: {schema: AnalyzeWebsiteCodeOutputSchema},
  system: `You are an AI expert in website security and advanced technology stack identification, designed to be significantly more comprehensive than tools like Wappalyzer.
Your primary goal is to analyze the provided HTML content, headers, cookies, and other data of a website to augment the list of already signature-detected technologies.
The user has provided the URL: {{{url}}}
The HTML content, and potentially HTTP headers and cookies, are provided.
A list of technologies already detected by a signature-based scanner (which itself uses HTML, headers, cookies, URL patterns, etc.) is provided in 'signatureBasedDetections'. Your role is to:
1.  **Deeply Analyze Obfuscated/Minified Code**: Go beyond simple signatures. Examine inline scripts, minified bundles, and any obfuscated code for patterns, unique strings, or function structures that indicate specific libraries or frameworks NOT caught by the initial scan or to confirm initial scans with higher confidence from code behavior. This includes analyzing inline script content and looking for patterns in how DOM elements are manipulated. Actively search for signs of code obfuscation (e.g., packed code, mangled variable names, large hex/base64 arrays) and attempt to infer the underlying technologies or their characteristics.
2.  **Correlate Information**: Use HTML, headers, cookies, and signature-based detections together. For example, if a header suggests a certain server-side technology, look for corroborating evidence in the HTML. If a cookie suggests a framework, look for its JS patterns.
3.  **Infer Technologies**: Look for:
    *   JavaScript frameworks and libraries (e.g., React, Angular, Vue, jQuery, Svelte, Next.js, Nuxt.js, Ember.js, Backbone.js, Preact, Lodash, Underscore) by analyzing global variables, specific API usage in scripts, or characteristic HTML attributes.
    *   UI libraries and frameworks (e.g., Bootstrap, Tailwind CSS, Materialize, Foundation, Semantic UI, Emotion, Styled Components, Ant Design, Material-UI) from CSS classes, script patterns, or specific HTML structures.
    *   Server-side technologies hinted at in the HTML, HTTP headers (e.g., 'Server', 'X-Powered-By'), or cookie names (e.g., PHPSESSID, JSESSIONID, ASP.NET_SessionId).
    *   Content Management Systems (CMS) (e.g., WordPress, Joomla, Drupal, Shopify, Wix, Squarespace, Ghost) - confirm or find if not in signatures, looking at meta tags, unique path structures in URLs, or specific HTML comments.
    *   Analytics and tracking tools (e.g., Google Analytics, Mixpanel, Segment, Hotjar, Matomo, Amplitude, Heap) from script sources, global JS objects, or cookie names.
    *   Advertising networks, CDNs, Web servers/hosting platforms (from headers, URL patterns).
    *   Font scripts/services, Widgets/third-party embeds, Client-side languages (JS, TS if hints), Build tools (from manifest patterns, script structures).
    *   Evidence of WebAssembly, State management libraries, GraphQL clients.
4.  **Identify Potential Security Concerns**: Based on your deep analysis and the identified technologies (both signature-based and newly found):
    *   Use of outdated libraries with *known* vulnerabilities (if version is identifiable).
    *   Missing or weak security headers (e.g., CSP, X-Frame-Options, HSTS - analyze provided headers).
    *   Insecure cookie attributes (e.g., missing HttpOnly, Secure flags - analyze cookie strings if provided).
    *   Mixed content (http resources on an https page).
    *   Exposed API keys or sensitive information in client-side code (look for common key patterns).
    *   Common vulnerabilities associated with detected technologies/versions.
    *   Insecure SRI (Subresource Integrity) practices.
    *   Presence of known trackers or scripts associated with malware/adware.
    *   Hardcoded credentials, use of 'eval()', verbose error messages.

**Deep Analysis Instructions for AI (Beyond Signatures):**
*   **Examine Minified and Obfuscated Code:** Actively look for patterns, unique string literals, or function structures within inline <script> tags that are characteristic of specific libraries, even if the code is minified or lightly obfuscated. For example, jQuery often uses '$' or 'jQuery' globals, React might leave '__REACT_DEVTOOLS_GLOBAL_HOOK__' or specific DOM attribute patterns like 'data-reactroot'.
*   **Fingerprinting:** Identify technologies by their "fingerprints" – unique CSS class name prefixes (e.g., 'wp-' for WordPress, 'v-' for Vue), specific HTML comment patterns, meta tags (e.g., '<meta name="generator" content="WordPress 5.x">'), inline JSON-LD, or unique IDs/structures.
*   **Script Tag Analysis:** Analyze 'src' attributes of <script> and <link> tags. Even if you can't fetch the content, the URL structure can reveal CDNs (e.g., cdnjs, unpkg, jsdelivr) or specific services. Look for version numbers in these URLs.
*   **Aggressive technology Inference from Obfuscated Code**: Even if code is heavily obfuscated, attempt to infer technologies by identifying characteristic patterns. For example:
    *  Look for large base64 encoded strings which can indicate the presence of minified assets or inline images.
    *  Detect eval() calls or Function() constructors, which are often used to dynamically generate code. Trace the inputs to these calls if possible.
    *  Analyze variable names and string literals, even if they are obfuscated. Some obfuscation techniques leave recognizable fragments.
    *  Identify patterns in how DOM elements are created and manipulated, which might be unique to certain frameworks.
*   **Global Variables & Inline Scripts:** Infer technologies from global variables (e.g., window.jQuery, window.angular, window.dataLayer) or patterns in inline script content.
*   **HTML Structure & Comments:** Look for characteristic HTML structures, 'data-*' attributes, or revealing comments.
*   **JSON-LD and Microdata:** Analyze structured data.
*   **Header and Cookie Analysis**: If headers and cookies are provided, analyze them for clues. E.g., 'Server' header for web server, 'Set-Cookie' for session management frameworks.

**Output Formatting for Each Detected Technology (for technologies YOU newly identify or refine):**
- "id": (Optional) Your internal identifier for this AI-driven detection rule if applicable.
- "technology": The common name of the technology/library/framework.
- "version": (Optional) The detected version, if identifiable.
- "confidence": Your confidence score (0.0 to 1.0). Be realistic.
- "isHarmful": (Optional) Boolean. True if poses a security risk.
- "detectionMethod": A *detailed* explanation of *how* you identified this via AI reasoning. Examples: "AI: Inferred from minified code pattern 'lodash.debounce'", "AI: Global var 'window.__APOLLO_CLIENT__'", "AI: Header 'X-Powered-By: Express'".
- "category": (Optional) Categorize the technology.
- "matchedValue": (Optional) Specific code snippet, header value, or URL part.
- "website": (Optional) Official website.
- "icon": (Optional) Icon filename.

Combine your AI-driven findings with 'signatureBasedDetections'. If your analysis confirms a signature-based detection with more detail (e.g., a more specific version or higher confidence from code analysis), update that entry. Add new technologies not found by signatures.
The 'analysisSummary' should be a concise overview of ALL findings, including difficulties.
If HTML content is null/empty, state analysis cannot proceed.
Critically evaluate the 'signatureBasedDetections'. If a signature detection seems low confidence or generic, try to find stronger evidence in the code or headers to confirm, refine, or even refute it.
Your goal is a comprehensive and accurate list. Prioritize depth of analysis over breadth if necessary due to token limits.
Focus especially on JavaScript frameworks/libraries and their versions.
If the site is complex like Netflix, expect heavy obfuscation and dynamic loading. Look for clues related to build tools (Webpack, Parcel), module loaders, and large JavaScript bundles.
Identify if a site is a Single Page Application (SPA) and what framework might be powering it.
Provide as much detail as possible for your 'detectionMethod' for any new or refined technologies.
`,
});

const analyzeWebsiteCodeFlow = ai.defineFlow(
  {
    name: 'analyzeWebsiteCodeFlow',
    inputSchema: AnalyzeWebsiteCodeInputSchema,
    outputSchema: AnalyzeWebsiteCodeOutputSchema,
  },
  async (input): Promise<AnalyzeWebsiteCodeOutput> => {
    const flowLogPrefix = `[AIFlow/analyzeWebsiteCodeFlow URL: ${input.url}]`;
    console.log(`${flowLogPrefix} Flow starting.`);

    const pageContentResult = await retrievePageContentTool({ url: input.url });

    if (!pageContentResult.html || pageContentResult.error) {
      console.warn(`${flowLogPrefix} Failed to retrieve HTML: ${pageContentResult.error || 'No HTML content'}`);
      return {
        detectedTechnologies: [],
        securityConcerns: [],
        analysisSummary: `Failed to retrieve website content for ${input.url}. Error: ${pageContentResult.error || 'No HTML content returned.'} Analysis cannot proceed. (Status: ${pageContentResult.status})`,
      };
    }
    console.log(`${flowLogPrefix} HTML content retrieved. Length: ${pageContentResult.html.length}. Headers received: ${!!pageContentResult.headers}, Cookies: ${!!pageContentResult.cookies}`);

    let signatureDetections: DetectedTechnology[] = [];
    try {
      const detectionEngineInput: DetectionInput = {
          url: pageContentResult.finalUrl || input.url,
          htmlContent: pageContentResult.html,
          headers: pageContentResult.headers,
          cookies: pageContentResult.cookies,
      };
      const signatureResults: SignatureDetectedTechInfo[] = detectWithSignatures(detectionEngineInput);
      signatureDetections = signatureResults.map(sr => ({
        id: sr.id,
        technology: sr.name,
        version: sr.version,
        confidence: sr.confidence,
        isHarmful: undefined, 
        detectionMethod: sr.detectionMethod,
        category: sr.category,
        matchedValue: sr.matchedValue,
        website: sr.website,
        icon: sr.icon,
      }));
      console.log(`${flowLogPrefix} Signature-based detection found ${signatureDetections.length} technologies.`);
      signatureDetections.forEach(tech => console.log(`  ${flowLogPrefix} - Signature: ${tech.technology} (v${tech.version || 'N/A'}, conf: ${tech.confidence}) via ${tech.detectionMethod}`));
    } catch (e: any) {
      console.error(`${flowLogPrefix} Error during signature-based detection:`, e.message, e.stack);
      console.error(`${flowLogPrefix} Full signature error object:`, JSON.stringify(e, Object.getOwnPropertyNames(e)));
    }

    const promptInput: z.infer<typeof AnalyzeWebsiteCodePromptInputSchema> = {
        url: pageContentResult.finalUrl || input.url,
        htmlContent: pageContentResult.html, 
        headers: pageContentResult.headers,
        cookies: pageContentResult.cookies,
        signatureBasedDetections: signatureDetections,
    };
    
    console.log(`${flowLogPrefix} AI Prompt input being prepared. HTML length: ${promptInput.htmlContent.length}, Num Headers: ${Object.keys(promptInput.headers || {}).length}, Signature Detections: ${promptInput.signatureBasedDetections.length}`);

    const MAX_HTML_LENGTH_FOR_PROMPT = 700000; // Increased limit
    if (promptInput.htmlContent.length > MAX_HTML_LENGTH_FOR_PROMPT) {
      console.warn(`${flowLogPrefix} HTML content is very large (${promptInput.htmlContent.length} chars), truncating to ${MAX_HTML_LENGTH_FOR_PROMPT} chars for AI prompt.`);
      promptInput.htmlContent = promptInput.htmlContent.substring(0, MAX_HTML_LENGTH_FOR_PROMPT);
    }


    const {output: aiOutput, error: aiError, usage: aiUsage} = await analyzeWebsiteCodePrompt(promptInput);
    console.log(`${flowLogPrefix} AI Prompt usage:`, JSON.stringify(aiUsage));


    if (aiError) {
      console.error(`${flowLogPrefix} AI Prompt returned an error:`, aiError);
      console.error(`${flowLogPrefix} Full AI error object:`, JSON.stringify(aiError, Object.getOwnPropertyNames(aiError)));
      return {
        detectedTechnologies: signatureDetections, 
        securityConcerns: [],
        analysisSummary: `AI analysis encountered an error: ${aiError.message || 'Unknown AI error'}. Displaying signature-based detections only. (Check server logs for more details)`,
      };
    }
    
    if (!aiOutput) {
      console.error(`${flowLogPrefix} AI Prompt returned no output.`);
      return {
        detectedTechnologies: signatureDetections,
        securityConcerns: [],
        analysisSummary:
          'AI analysis failed: The AI model did not return a valid output. Displaying signature-based detections only.',
      };
    }
    console.log(`${flowLogPrefix} AI Prompt output received. Technologies from AI: ${aiOutput.detectedTechnologies?.length}, Concerns: ${aiOutput.securityConcerns?.length}`);
    
    const finalDetectedTechnologies = new Map<string, DetectedTechnology>();
    
    signatureDetections.forEach(tech => {
        finalDetectedTechnologies.set(tech.technology.toLowerCase() + (tech.version || ''), tech);
    });

    if (aiOutput.detectedTechnologies) {
        aiOutput.detectedTechnologies.forEach(aiTech => {
            const key = aiTech.technology.toLowerCase() + (aiTech.version || '');
            const existingSignature = signatureDetections.find(
              sigTech => sigTech.technology.toLowerCase() === aiTech.technology.toLowerCase() && 
                         (!sigTech.version || !aiTech.version || sigTech.version === aiTech.version) // Match if versions are same or one is undefined
            );

            if (existingSignature) {
                 // AI is refining or confirming a signature detection
                finalDetectedTechnologies.set(key, {
                    ...existingSignature, // Start with signature base
                    ...aiTech,           // Overlay with AI's findings
                    // AI's confidence, version, and isHarmful should take precedence if provided
                    confidence: aiTech.confidence !== undefined ? aiTech.confidence : existingSignature.confidence,
                    version: aiTech.version || existingSignature.version,
                    isHarmful: aiTech.isHarmful !== undefined ? aiTech.isHarmful : existingSignature.isHarmful,
                    // Prepend AI's detection method if it's specific, otherwise show it's AI-refined
                    detectionMethod: aiTech.detectionMethod.startsWith("AI:") 
                                     ? `${aiTech.detectionMethod} (refined from: ${existingSignature.detectionMethod})`
                                     : `AI Refined: ${aiTech.detectionMethod} (Original: ${existingSignature.detectionMethod})`,
                });
            } else {
                // New detection purely from AI
                finalDetectedTechnologies.set(key, aiTech);
            }
        });
    }
    
    const combinedOutput: AnalyzeWebsiteCodeOutput = {
        detectedTechnologies: Array.from(finalDetectedTechnologies.values()),
        securityConcerns: aiOutput.securityConcerns || [],
        analysisSummary: aiOutput.analysisSummary || 'Analysis summary not provided by AI.',
    };

    console.log(`${flowLogPrefix} Combined analysis successful. Detected ${combinedOutput.detectedTechnologies.length} unique technologies and ${combinedOutput.securityConcerns.length} concerns.`);
    combinedOutput.detectedTechnologies.forEach(tech => console.log(`  ${flowLogPrefix} - Final: ${tech.technology} (v${tech.version || 'N/A'}, conf: ${tech.confidence}) via ${tech.detectionMethod}, Harmful: ${tech.isHarmful === undefined ? 'N/A' : tech.isHarmful}`));

    return combinedOutput;
  }
);

