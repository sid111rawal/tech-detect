// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview Flow for analyzing website code to detect technologies using signature-based methods.
 * This flow now orchestrates calls to signature-based detection and does not use AI for analysis.
 *
 * - analyzeWebsiteCode - A function that analyzes website code.
 * - AnalyzeWebsiteCodeInput - The input type for the analyzeWebsiteCode function.
 * - AnalyzeWebsiteCodeOutput - The return type for the analyzeWebsiteCode function.
 */

import {ai} from '@/ai/genkit'; // genkit is still used for flow definition structure
import {z}  from 'genkit';
import {retrievePageContent, type PageContentResult} from '@/services/page-retriever';
import { detectTechnologies, type DetectedTechnologyInfo } from '@/lib/signatures';

// Define the schema for detected technologies (matching DetectedTechnologyInfo from signatures.ts)
const DetectedTechnologySchema = z.object({
  id: z.string().optional().describe('An identifier for the detection rule or signature if applicable.'),
  technology: z.string().describe('The name of the detected technology, library, or framework.'),
  version: z.string().nullable().optional().describe('The detected version of the technology, if identifiable.'),
  confidence: z.number().min(0).max(100).describe('The confidence score (0 to 100) of this detection.'), // Updated to 0-100
  isHarmful: z.boolean().optional().describe('Whether this technology is considered harmful (can be manually set in signatures or by other logic).'),
  detectionMethod: z.string().optional().describe('Brief description of how this technology was identified (e.g., "Signature: React (scriptSrc)", "Matched: Server Header").'),
  category: z.string().optional().describe('A category for the technology (e.g., "JavaScript Framework", "Analytics", "CMS").'),
  matchedValue: z.string().optional().describe('The actual string value from the source code or headers that matched a pattern.'),
  website: z.string().optional().describe('Official website of the technology, if known.'),
  icon: z.string().optional().describe('Filename of the technology icon (e.g., "React.svg").'),
});
export type DetectedTechnology = z.infer<typeof DetectedTechnologySchema>;


const AnalyzeWebsiteCodeInputSchema = z.object({
  url: z.string().url().describe('The URL of the website to analyze.'),
});
export type AnalyzeWebsiteCodeInput = z.infer<typeof AnalyzeWebsiteCodeInputSchema>;

const AnalyzeWebsiteCodeOutputSchema = z.object({
  detectedTechnologies: z.array(DetectedTechnologySchema).describe('A list of detected technologies with their details.'),
  // securityConcerns: z.array(z.string()).describe('A list of potential security concerns identified. (This is now handled by signature rules if any)'),
  analysisSummary: z.string().describe('A brief summary of the analysis.'),
  error: z.string().optional().describe('An error message if the analysis failed at a high level.'),
});
export type AnalyzeWebsiteCodeOutput = z.infer<typeof AnalyzeWebsiteCodeOutputSchema>;

export async function analyzeWebsiteCode(
  input: AnalyzeWebsiteCodeInput
): Promise<AnalyzeWebsiteCodeOutput> {
  console.log('[FlowWrapper/analyzeWebsiteCode] Calling flow with input:', input);
  try {
    const result = await analyzeWebsiteCodeFlow(input);
    console.log('[FlowWrapper/analyzeWebsiteCode] Flow returned result:', result);
    return result;
  } catch (error) {
    console.error('[FlowWrapper/analyzeWebsiteCode] Error calling flow:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return {
      detectedTechnologies: [],
      // securityConcerns: [],
      analysisSummary: `Error during analysis: ${errorMessage}. The website content might be inaccessible or an unexpected issue occurred.`,
      error: `Error during analysis: ${errorMessage}.`
    };
  }
}

// No retrievePageContentTool needed here anymore as retrievePageContent is called directly.

const analyzeWebsiteCodeFlow = ai.defineFlow(
  {
    name: 'analyzeWebsiteCodeFlow',
    inputSchema: AnalyzeWebsiteCodeInputSchema,
    outputSchema: AnalyzeWebsiteCodeOutputSchema,
    // Removed AI model and prompt as this is now a signature-only flow
  },
  async (input): Promise<AnalyzeWebsiteCodeOutput> => {
    const flowLogPrefix = `[SignatureFlow/analyzeWebsiteCodeFlow URL: ${input.url}]`;
    console.log(`${flowLogPrefix} Flow starting (Signature-Based Only).`);

    const pageContentResult: PageContentResult = await retrievePageContent(input.url);

    if (pageContentResult.error || !pageContentResult.html) {
      console.warn(`${flowLogPrefix} Failed to retrieve HTML: ${pageContentResult.error || 'No HTML content'}`);
      return {
        detectedTechnologies: [],
        // securityConcerns: [],
        analysisSummary: `Failed to retrieve website content for ${input.url}. Error: ${pageContentResult.error || 'No HTML content returned.'} Analysis cannot proceed. (Status: ${pageContentResult.status})`,
        error: `Failed to retrieve website content for ${input.url}. Error: ${pageContentResult.error || 'No HTML content returned.'} (Status: ${pageContentResult.status})`,
      };
    }
    console.log(`${flowLogPrefix} HTML content retrieved. Length: ${pageContentResult.html.length}. Headers received: ${!!pageContentResult.headers}, Cookies: ${!!pageContentResult.cookies}, Final URL: ${pageContentResult.finalUrl}`);

    let signatureDetections: DetectedTechnologyInfo[] = [];
    try {
      // Use detectTechnologies from src/lib/signatures.ts
      // It now requires pageContentResult and finalUrl
      signatureDetections = await detectTechnologies(pageContentResult, pageContentResult.finalUrl || input.url);
      
      console.log(`${flowLogPrefix} Signature-based detection found ${signatureDetections.length} technologies.`);
      signatureDetections.forEach(tech => console.log(`  ${flowLogPrefix} - Signature: ${tech.technology} (v${tech.version || 'N/A'}, conf: ${tech.confidence}) via ${tech.detectionMethod}`));

    } catch (e: any) {
      console.error(`${flowLogPrefix} Error during signature-based detection:`, e.message, e.stack);
      // Log the full error object for more details if available
      if (typeof e === 'object' && e !== null) {
          console.error(`${flowLogPrefix} Full error object:`, JSON.stringify(e, Object.getOwnPropertyNames(e)));
      }
      return {
        detectedTechnologies: [],
        // securityConcerns: [],
        analysisSummary: `Error during signature-based detection: ${e.message || 'Unknown error'}. Check server logs for details.`,
        error: `Error during signature-based detection: ${e.message || 'Unknown error'}.`,
      };
    }
    
    const analysisSummary = signatureDetections.length > 0
        ? `Signature-based analysis complete. Detected ${signatureDetections.length} technology/technologies for ${input.url}.`
        : `Signature-based analysis complete. No technologies detected with current signatures for ${input.url}.`;

    // Map DetectedTechnologyInfo to DetectedTechnology (Zod schema type)
    const outputTechnologies: DetectedTechnology[] = signatureDetections.map(techInfo => ({
        id: techInfo.id,
        technology: techInfo.technology,
        version: techInfo.version,
        confidence: techInfo.confidence, // Assuming confidence is already 0-100
        isHarmful: techInfo.isHarmful,
        detectionMethod: techInfo.detectionMethod,
        category: techInfo.category,
        matchedValue: techInfo.matchedValue,
        website: techInfo.website,
        icon: techInfo.icon,
    }));

    const output: AnalyzeWebsiteCodeOutput = {
        detectedTechnologies: outputTechnologies,
        // securityConcerns: [], // No AI to generate security concerns
        analysisSummary: analysisSummary,
    };

    console.log(`${flowLogPrefix} Signature-based analysis successful. Detected ${output.detectedTechnologies.length} technologies.`);
    return output;
  }
);
